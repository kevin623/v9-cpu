#论文1：
Redundant software (and hardware) ensured Curiosity reached its destination and functioned as its designers intended.
#作者： 
Gerard J. Holzmann
#论文主要内容：
	星际飞船控制软件的设计必须具有高标准的可靠性，任何细小的错误皆能造成任务失败，错失拓展人类知识的宝贵机会。在硬件和软件上均取了特别的措施，确保航天器可靠运行，并且系统能够在数百万英里之外进行调试和修复。形式化方法有助于验证复杂软件子系统中可能存在的争用情形和死锁；新型的模型检查技术可以实现这一验证过程的自动化。
	文章着重介绍飞行软件团队在开发 MSL 任务软件过程中采取的的预防措施。作者将内容归纳为三方面：首先是作者采用的代码编写标准，它具有稀疏、基于风险和受自动化合规性检查工具支持的特点；其次是作者采用了被重新定义的代码审核流程，它可以让作者高效地对大量代码进行全面的清理，这也是利用工具来完成的；第三是逻辑模型检查工具，它可以形式化验证任务关键型代码段中是否存在与并发相关的缺陷。

	基于风险的代码编写规则。
		根据航天领域最长出现的错误类型和产生根本原因进行分类，制作了一份主要问题清单。其中包含了基本的代码编写和设计错误，尤其是不规范使用多务处理而造成的错误。其他频发错误则源于对动态内存分配技术的使用，这在早期的空间探索中常常意味着对动态内存覆盖的使用。最后，数据还表明，即便是标准的故障保护技术也有意外的副作用，可能导致任务失败。作者根据这项研究而制定的代码编写标准与其他众多标准的区别在于，它仅包含风险相关的规则，而没有风格相关的规则。其中包括：
		LOC-1：语言合规 （2 条规则）
		LOC-2：执行可预测 （ 10条规则）
		LOC-3：防御型编码 （7条规则）
		LOC-4：代码清晰明了 （ 12条规则）
		LOC-5：所有 MISRA必须遵守的规则 （73条规则）
		LOC-6：所有 MISRA应当遵守的规则 （16 条规则）

	基于工具的代码审核。 
		即使最强健的代码编写规则也不能预防所有软件缺陷。这意味着，务必要尽量设计出更多方法来捕获那些“漏网之鱼”，而且要尽早对这些方法多加利用。检查软件的一个标准机制是同行代码审核。在传统的同行代码审核会议中，有一个引导式代成效显著，但对于更实际的工作，即检查规则遵从性和避免常见代码编写错误等普通问题，这种方法不那么可靠。好在这正是静态源代码分析工具的用武之地。静态代码分析器不会因夜以继日地反复检查同一类型错误而疲倦，它们会耐心地报告所有违规情况。因此作者广泛利用了这一技术。
		市面上商用静态源代码分析工具种类繁多，而且各有长处。作者发现，对同一代码运行多种分析器效果很好；不同工具的输出结果竟然鲜有重叠。这一发现促使作者在MSL 任务的夜间整合版中，对所有代码运行四个（而不是一个）分析器。作者选用的分析器（即 Coverity、 Codesonar、 Semmle 和 Uno）必须能够识别可能的缺陷，具有合理的较低误报率，能够高效地处理数百万行代码，并且允许定义自定义检查（例如验证是否遵从作者的代码编写标准中的规则）。利用简单的后处理脚本对每项工具的输出进行统一的重格式化，因此所有工具报告都可在作者开发的一款供应商中立的代码审核工具（名为Scrub）中查阅。 Scrub工具经过特别设计，能够在单个用户界面中整合静态分析器和其他各种后台检查器的输出，同时还提供人工完成的同行代码审核意见。 2008 至 2012 年 期 间 针 对MSL 飞行软件共举行了 145 次代码审核会议，讨论了大约 10,000条同行意见和 30,000 份由工具生成的报告。在所有意见和工具报告中，大约有 84% 导致代码更改以解决其涉及的问题。同行填写的报告与工具生成的报告在这一比率上的差距不到2%。

	模型检查。 
		在作者用于分析多线程代码的“武器库”中，最强的一种检查方法是逻辑模型检查。MSL任务的代码大量使用了多线程，在实时操作系统的控制下执行120 项并行任务。因此，总是有可能发生争用情形，而且这也是过去任务中出现异常的一大原因。为全面分析代码的争用情形，作者广泛利用了逻辑模型检查器 Spin 10 的功能，以及 C 代码模型提取工具的一个扩展版本。
		作者分析了 MSL 任务的多个关键软件组件，通过这些分析识别的多个漏洞可以在任务启动之前从代码中剔除，有效地帮助降低飞行过程
		中发生意外事件的几率。要手动证明一种并发算法在所有可能的执行条件下都是正确的可能太过困难。Lamport15 后来在 +CAL 中形
		式化了原始算法，其表明可以通过模型检查器更加快速地找出那些瑕疵。 Lamport 提到，利用 TLA+ 模型检查器进行证明可以在两天以内
		完成，需要做的大部分工作是使用模型检查器支持的语言为原始算法定义一个形式化模型。正如此处所示，模型提取器还可以免去手动构建形式化模型的需要，使作者能够在数分钟内对多线程代码片段执行这类验证，而不需要几天时间。作者用 Detlefs2 的原始算法来演示这一验证方式的工作
		原理。通过这种方式，查找代码实现中的缺陷仅需要输入几行文本再执行一个命令即可。作者可以对读取器和写入器使用不同的线程来进行测试，虽然这些测试本身并不足以证明该算法的正确性。模型检查器经过设计，可更加严格地执行此类检查。如果存在任何可能的线程执行交错而导致断言失败，模型检查器可保证找到它。
		现在可以利用模型提取工具Modex 和模型检查器 Spin 通过一条命令来执行算法的验证。该命令实际运行时需要大约 12秒，其中只有 0.02 秒用于验证本身。运行时的其余部分供模型提取器用于从源代码生成验证模型，供 Spin将该模型转换为优化的 C 代码，并最终供 C 编译器生成执行该验证的可执行文件。这些步骤都不需要用户的进一步干预。错误踪迹的重演显示了可导致断言违规的争用情形，进而表明该算法存在错误。模型提取方法被设计成可在基本应用程序中实现非常简单的检测类型。模型提取器始终保留应用程序的原始控制流。不过，它也支持在配置文件中定义更加高级的抽象函数，用来降低所提取模型的复杂度。默认转换规则（定义了语句从源代码到模型的	一对一映射）可以直接验证数量巨大的多线程 C 程序和算法。MSL 任务广泛使用这一自动化功能，通过直接利用关键多线程算法在 C 中的实现对它们进行验证。对于更大型的子系统，作者也通过比较传统的方式手动构建了Spin 验证模型，并对它们进行分析。在大多数情形中，模型检查的运行都可成功标出软件中难以捕获的并发性错误，然后这些错误可以被修复。尤其对于文件系统软件而言，模型检查的运行已成为作者“回归测试”的一个例行环节，每一次更改代码后都会执行。它能够轻松识别新出现的代码编写错误，因而常常给作者带来惊喜。
	冗余措施
		作者采取了各项预防措施来增加成功几率，而不仅仅在软件开发方面。关键硬件组件都有备用副本，包括火星车的主 CPU。虽然很容易可以看出基本硬件组件的复制是如何改善系统可靠性的，但冗余对于改善软件可靠性的作用却不那么显而易见。第一个示例强调了在整个代码中使用断言，这一点听上去可能很明显，但极少被承认是基于冗余的保护机制。断言始终都要得到满足，这意味着严格来说，对它的评估几乎始终是冗余的。但有时，不可能发生的事的确会发生，例如，当外部条件的变化无法预见时。断言的价值在于能在执行中尽早检测出非正常状况，使得故障保护监控程序可以采取措施预防损害。软件冗余的第二个示例用于保护关键的着陆序列。这是任务中唯一同时使用主 CPU 和其备份的阶段（备份处于热待机状态）。如果在两个 CPU 行运行相同的着陆软件，那么就几乎无法提供保护以应对软件缺陷。因此，作者开发了两个版本的“进入至降落与着陆”代码，主 CPU 运行的是主版本，备份 CPU 上运行的是简化版。如果在着陆序列中主 CPU 发生意外故障，备份 CPU 被设定为自动接管，可按照简化的过程继续执行该序列。软件的备份版本有个恰如其分的名称，即“二次机会”。让大家欣慰的是，事实证明这个备份版本是“冗余”的，因为它从未被调用执行。
